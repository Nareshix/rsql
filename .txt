fn main(){
    let conn = Connection::open("")

    conn.prepare("").binding().step();
    
    let result = conn.prepare("").binding().query();
    for i in result {
        do whatever
    }

    let result = conn.prepare("").binding().query();
    take_iterator(result)


    let result = conn.prepare("").binding().query();
    take_iterator(&result)
   


    execute!(conn, sql, binding)

    let result = query!(conn, mapping, sql, binding);

}





#[lazyinit]
pub struct User{
    // db: conn,

    #[sql("SELECT * FROM users WHERE id = ?"), (bind)]
    create_users: LazyStmt,

    #[sql(mapping, "INSERT INTO users (name) VALUES (?)"), (bind)]
    get_user: LazyStmt,
}

let conn = Connection::open_memory()
let mut user = User::new(&conn);

user.create_users()
let result = user.get_user()



only drop the db when conn goes out of scope







{
        let stmt = dao.q_item_count()?;
        stmt.bind_parameter(1, 0)?; 
        for row in stmt.query(OrdersItemCount) {
            println!(" mom {:?}", row?);
        }
    } // stmt drops -> resets & clears bindings

    or manually drop stmt

let result = query!(mapping, dao.q_item_count(), (binding_paramers))

let result = query!(conn, mapping, sql, binding);
